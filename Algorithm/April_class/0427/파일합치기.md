# 파일합치기

----
## 문제
소설가인 김대전은 소설을 여러 장(chapter)으로 나누어 쓰는데, 각 장은 각각 다른 파일에 저장하곤 한다. 소설의 모든 장을 쓰고 나서는 각 장이 쓰여진 파일을 합쳐서 최종적으로 소설의 완성본이 들어있는 한 개의 파일을 만든다. 이 과정에서 두 개의 파일을 합쳐서 하나의 임시파일을 만들고, 이 임시파일이나 원래의 파일을 계속 두 개씩 합쳐서 소설의 여러 장들이 연속이 되도록 파일을 합쳐나가고, 최종적으로는 하나의 파일로 합친다. 두 개의 파일을 합칠 때 필요한 비용(시간 등)이 두 파일 크기의 합이라고 가정할 때, 최종적인 한 개의 파일을 완성하는데 필요한 비용의 총 합을 계산하시오.

예를 들어, C1, C2, C3, C4가 연속적인 네 개의 장을 수록하고 있는 파일이고, 파일 크기가 각각 40, 30, 30, 50 이라고 하자. 이 파일들을 합치는 과정에서, 먼저 C2와 C3를 합쳐서 임시파일 X1을 만든다. 이때 비용 60이 필요하다. 그 다음으로 C1과 X1을 합쳐 임시파일 X2를 만들면 비용 100이 필요하다. 최종적으로 X2와 C4를 합쳐 최종파일을 만들면 비용 150이 필요하다. 따라서, 최종의 한 파일을 만드는데 필요한 비용의 합은 60+100+150=310 이다. 다른 방법으로 파일을 합치면 비용을 줄일 수 있다. 먼저 C1과 C2를 합쳐 임시파일 Y1을 만들고, C3와 C4를 합쳐 임시파일 Y2를 만들고, 최종적으로 Y1과 Y2를 합쳐 최종파일을 만들 수 있다. 이때 필요한 총 비용은 70+80+150=300 이다.

소설의 각 장들이 수록되어 있는 파일의 크기가 주어졌을 때, 이 파일들을 하나의 파일로 합칠 때 필요한 최소비용을 계산하는 프로그램을 작성하시오.

### 입력
프로그램은 표준 입력에서 입력 데이터를 받는다. 프로그램의 입력은 T개의 테스트 데이터로 이루어져 있는데, T는 입력의 맨 첫 줄에 주어진다.각 테스트 데이터는 두 개의 행으로 주어지는데, 첫 행에는 소설을 구성하는 장의 수를 나타내는 양의 정수 K (3 ≤ K ≤ 500)가 주어진다. 두 번째 행에는 1장부터 K장까지 수록한 파일의 크기를 나타내는 양의 정수 K개가 주어진다. 파일의 크기는 10,000을 초과하지 않는다.

### 출력
프로그램은 표준 출력에 출력한다. 각 테스트 데이터마다 정확히 한 행에 출력하는데, 모든 장을 합치는데 필요한 최소비용을 출력한다.

### 예제 입력
```python
2
4
40 30 30 50
15
1 21 3 4 5 35 5 4 3 5 98 21 14 17 32
```
### 예제 출력
```python
300
864
```

## 문제 풀이
### 1. 실패
주어진 숫자 2개씩 합치기,
DP 배열 저장 X -> func호출 -> top-down 방식 풀이
재귀 풀이
- 최악 (500-1)! 이기 때문에, 2초를 훨씬 넘김

```python
def dp(sm):
    global ans
    if sum(lst) == 0:
        if sm < ans:
            ans = sm
        return

    for i in range(N-1):
        for j in range(i+1,N):
            if lst[i] !=0 and lst[j] != 0:
                ij = lst[j]
                ii = lst[i]
                cnt = ii + ij
                lst[j] = 0
                lst[i] = cnt
                dp(sm+cnt)
                lst[j] = ij
                lst[i] = ii


T = int(input())
for test_case in range(1, T+1):
    N = int(input())
    lst = list(map(int, input().split()))
    ans = 10000*500
    dp(0)
    print(ans)
```

### 2. 실패
- sort -> 오름차순 정렬
- 작은 숫자부터 2개씩 더하기
```python
# sort, 최솟값

T = int(input())
for test_case in range(1, T+1):
    N = int(input())
    lst = list(map(int, input().split()))
    ans = []
    while len(lst) > 1:
        lst.sort()
        t = lst[0] + lst[1]
        ans.append(t)
        lst.append(t)
        lst.pop(0)
        lst.pop(0)

    print(sum(ans))
```
=> 최솟값으로 sort해서 하는 것 안됨


### 3. 문제 내 "연속적으로"
- 연속적으로 때문에, sort 하면 안됨 ....

# 3 연속적으로
```python
T = int(input())
for test_case in range(1, T+1):
    N = int(input())
    lst = list(map(int, input().split()))
    ans = 0
    k= 0
    while k != N-1:
        k += 1
        sm = [500 * 10000, 0]
        for i in range(len(lst)-1):
            n = lst[i] + lst[i+1]
            if n < sm[0]:
                sm = ([n, i])

        lst[sm[1]] = sm[0]
        lst.pop(sm[1]+1)
        ans += sm[0]
    print(ans)

```
- 이것도 실패
- 연속적이지만, 최적화는 실패했음
- 이로서 규칙 존재 X 그냥 하나하나씩 돌아다니면서 최솟값 확인하는 것


### 4 [i][j] 2차원 DP 활용 -> 풀이 참조
결국 우리가 하는 것 -> 선택된 최적 값들의 누적 
- 2차원 배열을 활용해 누적합 메모이제이션 처리
- 메모이제이션 DP 테이블
    - N * N 행렬 만듬
    - 행 -> 작업이 수행되는 단계, 길이
    - dp[i][j]는 i에서 j까지 이동하는 데 필요한 최소 비용
    
메모이제이션?
- 계산값을 저장하는 테이블(캐시)


예시 ->  40 , 30, 30, 50 (0,1,2,3 인덱스)


| |0|1|2|3|
|---|---|---|---|---|
|0|0|70|0|0|
|1|0|0|60|0|
|2|0|0|0|80|
|3|0|0|0|0|

길이가 3이 되려면?
- 1 + (2, 3)
- 1, 2 + 3
- 2, 3 +4
- 2 + 3, 4
이렇게 나눌 수 있는데, 여기서 min  값을 구하려면
  
  기존의 누적 값에서 최소가 되는 비용을 선택하면 됨

예를 들어

|1~3의 경우|비용|
|---|---|
|1, 2+3|1에서 1의 비용(0) + 2에서 3까지의 비용(60) = 60|
|1+2, 3|1에서 2까지의 비용(70) + 3에서 3까지의 비용(0) =70|

여기에서 가장 작은 min 값을 설정한 다음
1~3까지의 쪽수를 다 더한 후 dp 값을 더하면 된다.
- 누적합을 설정해놓으면 바로 더할 수 있음

풀이에서 구하고자 하는 것은 0에서 3까지 누적합의 최솟값
= dp[0][3] 값이 된다.

- 길이가 3일때

| |0|1|2|3|
|---|---|---|---|---|
|0|0|70|160|0|
|1|0|0|60|170|
|2|0|0|0|80|
|3|0|0|0|0|

- 길이가 4일 때

| |0|1|2|3|
|---|---|---|---|---|
|0|0|70|160|0|
|1|0|0|60|170|
|2|0|0|0|80|
|3|0|0|0|0|

min 값
- 1~1의 비용(0) + 2~4의 비용(170), 
- 1~2의 비용(70) + 3~4의 비용(80), <- min 값
- 1~3의 비용(160) + 4~4의 비용(0))

+(1~4까지의 누적합(150))



### code
```python
T = int(input())
for test_case in range(1, T+1): # 
  N = int(input())
  DP = [[0]*(N*1) for _ in range(N+1)]
  for i in range():


```

참고 https://data-make.tistory.com/402



